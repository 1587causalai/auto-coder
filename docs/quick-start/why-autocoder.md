# 为什么选择 AutoCoder?

AutoCoder 是一个务实的 AI 编程助手工具，它通过独特的方法论和设计理念解决了实际开发中的关键问题。本文将详细介绍 AutoCoder 的核心价值和它解决的具体问题。

## 核心差异化价值

### 1. 模拟真实开发流程
不同于简单的代码提示工具，AutoCoder 模拟了真实程序员的开发行为：
- 基于已有功能进行开发
- 参考项目现有代码
- 查阅第三方库文档
- 利用搜索引擎获取参考信息

### 2. 专注于可靠的代码修改
AutoCoder 不追求完全自动化，而是专注于让编码环节真正做到：
- 提高效率
- 保持稳定性
- 确保可靠性

### 3. 支持迭代式开发
采用"小步快跑"的开发方式：
- 将大型PR拆分成多个小型迭代
- 提供多种自动化程度选项：
  - 仅生成 Prompt
  - 自动执行 Prompt
  - 自动合并代码
- 使用 YAML 配置描述需求，便于回顾整个迭代过程

## 解决的核心问题

### 1. 项目代码理解问题
AutoCoder 能够：
- 阅读已有项目源码
- 理解第三方库文档
- 搜索并参考相关资料
- 基于完整上下文生成代码

### 2. 代码修改的安全性
通过提供：
- 不同级别的自动化选项
- 灵活的代码合并策略
- 让用户可以控制风险

### 3. 实际开发效率问题
采用清晰的开发流程：
1. 编写 YAML 文件描述需求
2. 自动生成并合并代码
3. 在 IDE 中审查代码
4. 根据需要进行手动调整
5. 必要时撤销并重新迭代

## 独特的方法论

### 1. 合理的粒度拆解
- 不追求一次性解决所有问题
- 强调任务的合理拆解
- 通过精确的需求描述控制代码质量
- 参考范例简化业务逻辑描述

### 2. 人机协作模式
- 保持程序员对代码的控制
- 将 AI 定位为助手而非替代者
- 在自动化和人工干预之间找到平衡

## 总结

AutoCoder 的价值主要体现在：

1. 在完全手动编码和完全 AI 自动化之间找到平衡点
2. 通过模拟真实开发流程，使 AI 辅助更符合实际需求
3. 采用迭代式开发方式，保证代码质量的同时提高开发效率
4. 让程序员保持对代码的控制，同时享受 AI 带来的效率提升

这使得 AutoCoder 成为一个更加务实和可落地的 AI 编程助手工具，而不是一个概念性的演示产品。它真正理解并解决了开发者在实际工作中面临的问题，提供了一个既能提高效率又能保证质量的解决方案。 

# FAQ


## 1. 这个项目的独特价值是什么？它到底解决了什么问题？


根据提供的文档，我来分析 AutoCoder 的核心价值和它解决的关键问题：


### 1. 核心差异化价值



1. **模拟真实开发流程**
- 不同于 GitHub Copilot 这样的代码提示工具，AutoCoder 模拟了真实程序员的开发行为，包括:

```11:19:docs/zh/为什么不是GithubCopilot,不是Devin而是AutoCoder.md
第二个维度是 Github Copilot 无法模拟人类的开发行为，我们实际做开发的时候，一般都是基于已有功能，并且根据某种“文档”，“第三方代码”和“搜索引擎”来进行开发。

比如 Byzer-LLM 要对接 Qwen-vl 多模态大模型，那么作为一个开发，我至少需要准备三个事情：

1. 首先我们需要了解和参考Byzer-LLM 之前是怎么对接各种模型的代码
2. 其次我要找到 Qwen-VL的API 文档了解 Qwen-VL 的API
3. 我可能还需要搜索下参考下别人是怎么对接的，以及如果我使用了第三方SDK，我还需要第三方SDK的文档或者代码。

只有获取了这些信息之后，我们才能写出一个靠谱的代码。但 Github copilot 能做到这些么？显然做不到。
```


2. **专注于可靠的代码修改**
- 不像 Devin 追求完全自动化但不稳定，AutoCoder 专注于:

```55:56:docs/zh/为什么不是GithubCopilot,不是Devin而是AutoCoder.md
AutoCoder专注在编码环节，相比需求分析，拆解，环境安装，构建项目，编写代码，自动debug,甚至自动运行测试，我们只专注在编程这个环节，让这个环节真正做到提效，稳定，可靠。

```


3. **支持迭代式开发**
- 采用小步快跑的开发方式:

```61:63:docs/zh/为什么不是GithubCopilot,不是Devin而是AutoCoder.md
此外，我们鼓励程序员使用进行小步快跑的方式使用AutoCoder,每次只做tiny 迭代，类似于人类一个大PR 需要拆解成几个小PR才能被提交。

此外，我们还提供了仅生成Prompt,自动执行Prompt,到自动merge代码 三种可选自动化程度，在每一步小迭代中都可以由用户来选择自动化什么程度。由于每一个小迭代，我们都采用了yml配置来描述需求，意味着用户可以回顾自己迭代的整个过程。
```


### 2. 解决的核心问题

1. **项目代码理解问题**
- 能够阅读已有项目源码、第三方库文档和搜索参考资料，从而更好地理解上下文
```markdown:docs/zh/命令行版Devin 来了_Auto-Coder.md
startLine: 269
endLine: 273
```

2. **代码修改的安全性**
- 提供了不同级别的自动化选项和代码合并策略，让用户可以控制风险
```markdown:docs/zh/015 - AutoCoder 迭代粒度拆解技巧.md
startLine: 11
endLine: 13
```

3. **实际开发效率问题**
- 通过合理的任务拆解和迭代方式提高开发效率:

```5:11:docs/zh/037-AutoCoder_项目快速修bug实战.md
使用 auto-coder 的开发流程如下：

1. 编写一个YAML文件来描述您的需求，Auto-Coder将生成代码并将代码合并到您的项目中。
2. 检查Auto-Coder的提交，并在vscode或其他IDE中审查代码。
3. 如果提交是基本满足需求，您可能仍需要使用github copilot或其他工具手动修改代码。
4. 如果auto-coder提交的代码不满足你需求，您需要撤销提交并修改YAML文件，并 1 步骤重新开始。
5. 重复上述步骤，直到您对auto-coder生成的代码满意。
```


### 3. 独特的方法论

1. **合理的粒度拆解**
- 不追求一次性解决所有问题，而是强调合理拆解任务:

```137:139:docs/zh/038-AutoCoder_为什么你需要经过反复练习才能用好.md
我们在做实际的项目迭代，你会发现，我们是要能够比较精准控制我们最后的代码的，因为你的代码要能够满足你已有项目的一些风格以及一些规范，包括你需要较为准确的控制你的代码的逻辑，所以正常你应该尽可能提供详细的需求和实现逻辑。通过参考范例，可以极大的简化你的业务逻辑描述。

你当然也可以提一个笼统的需求，但最后auto-coder 可能实现了你最后的目标，但是当你review commit 的时候，你可能会需要较多的修改满足项目自身的一些规范和需求。
```


2. **人机协作模式**
- 保持程序员对代码的控制，而不是完全依赖 AI:
```markdown:docs/zh/015 - AutoCoder 迭代粒度拆解技巧.md
startLine: 11
endLine: 13
```

### 总结

AutoCoder 的核心价值在于它找到了一个平衡点：

1. 在完全手动编码和完全 AI 自动化之间找到平衡
2. 通过模拟真实开发流程，让 AI 辅助更加符合实际需求
3. 采用迭代式开发方式，保证代码质量的同时提高开发效率
4. 让程序员保持对代码的控制，同时享受 AI 带来的效率提升

这使得 AutoCoder 成为一个更加务实和可落地的 AI 编程助手工具，而不是一个概念性的演示产品。
