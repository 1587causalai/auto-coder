
下面是一些文件路径以及每个文件对应的源码：

##File: /home/winubuntu/projects/ByzerRawCopilot/auto_coder.py
import importlib.util
import os
import ray
import ast
import byzerllm
from typing import List,Dict,Any
import argparse 
from autocoder.pyproject import PyProject,Level1PyProject
from autocoder.tsproject import TSProject
from autocoder.suffixproject import SuffixProject
import pydantic


@byzerllm.prompt(render="jinja")
def auto_implement_function_template(instruction:str, content:str)->str:
    '''
    下面是一些文件路径以及每个文件对应的源码：

    {{ content }}

    请参考上面的内容，重新实现所有文件下方法体标记了如下内容的方法：

    ```python
    raise NotImplementedError("This function should be implemented by the model.")
    ```
    
    {{ instruction }}
        
    '''
    pass

@byzerllm.prompt(render="jinja")
def instruction_template(instruction:str, content:str)->str:
    '''
    下面是一些文件路径以及每个文件对应的源码：

    {{ content }}    
    
    {{ instruction }}
        
    '''
    pass



class TranslateReadme(pydantic.BaseModel):
    filename:str = pydantic.Field(...,description="需要翻译的文件路径")
    content:str  = pydantic.Field(...,description="翻译后的内容")


class Translates(pydantic.BaseModel):
    readmes:List[TranslateReadme]
    

@byzerllm.prompt(render="jinja")
def translate_readme(content:str,lang:str)->str:
    '''
    下面是一些文件路径以及每个文件对应的内容：

    {{ content }}    
    
    请参考上面的内容，将上面的每一个文件对应的内容翻译成{{ lang }}。
    
    '''
    pass


def main():
    parser = argparse.ArgumentParser(description="Auto-implement missing methods in a Python script.")
    parser.add_argument("--source_dir", required=True, help="Path to the project")
    parser.add_argument("--git_url", help="URL of the git repository")
    parser.add_argument("--target_file", required=False, help="the file to write the source code to")
    parser.add_argument("--query",  help="the instruction to handle the source code")
    parser.add_argument("--template",  default="common",help="the instruction to handle the source code")
    parser.add_argument("--project_type",  default="py",help="the type of the project. py,ts,or py-script, default is py")
    parser.add_argument("--execute", action='store_true', help="Execute command line or not")    

    parser.add_argument("--package_name",  default="",help="only works for py-script project type. The package name of the script. default is empty.")
    parser.add_argument("--script_path",  default="",help="only works for py-script project type. The path to the Python script. default is empty.")

    parser.add_argument("--model",  default="",help="the model name to use")

    args = parser.parse_args()

    if args.model:
        byzerllm.connect_cluster()
        llm = byzerllm.ByzerLLM()
        llm.setup_template(model=args.model,template="auto")
        llm.setup_default_model_name(args.model)
    else:
        llm = None

    source_dir = args.source_dir    
    git_url = args.git_url or None
    target_file = args.target_file or None    
    template = args.template 
    project_type = args.project_type
    should_execute = args.execute

    lang = "中文"
    tranlate_file_suffix = ""

    if project_type == "ts":
        pp = TSProject(source_dir=source_dir, git_url=git_url, target_file=target_file)
    elif project_type == "py-script":
        pp = Level1PyProject(script_path=args.script_path, package_name=args.package_name)          
    elif project_type == "py":
        pp = PyProject(source_dir=source_dir, git_url=git_url, target_file=target_file)
    elif project_type.startswith("translate"):
        #translate/中文/.md/cn
        [_,lang,suffix,tranlate_file_suffix] = project_type.split("/")
        pp = SuffixProject(source_dir=source_dir, git_url=git_url, target_file=target_file,project_type=suffix) 
        template = "translate"
        lang = lang 
        should_execute = False
    else:
        pp = SuffixProject(source_dir=source_dir, git_url=git_url, target_file=target_file,project_type=project_type)

    pp.run()
    content = pp.output()
    
    if template == "common":
        instruction = args.query or "Please implement the following methods"
        content = instruction_template(instruction=instruction, content=content)
    elif template == "auto_implement":            
        content = auto_implement_function_template(instruction="", content=content)
    elif template == "translate":
        content = translate_readme(content=content,lang=lang)
        t = llm.chat_oai(conversations=[{
            "role": "user",
            "content": content
        }],response_class=Translates)         
        readmes:Translates = t[0].value
        for readme in readmes.readmes:
            filename, extension = os.path.splitext(readme.filename)
            chinese_filename = f"{filename}-{tranlate_file_suffix}{extension}"
            with open(chinese_filename, "w") as file:        
                file.write(readme.content)
                
        
    if should_execute:
        t = llm.chat_oai(conversations=[{
            "role": "user",
            "content": content
        }]) 
        content = t[0].output
    
    with open(target_file, "w") as file:        
        file.write(content)


if __name__ == "__main__":
    main()



    
    


##File: /home/winubuntu/projects/ByzerRawCopilot/src/autocoder/auto_coder.py
import importlib.util
import os
import ray
import ast
import byzerllm
from typing import List,Dict,Any
import argparse 
from autocoder.pyproject import PyProject,Level1PyProject
from autocoder.tsproject import TSProject


@byzerllm.prompt(render="jinja")
def auto_implement_function_template(instruction:str, content:str)->str:
    '''
    下面是一些文件路径以及每个文件对应的源码：

    {{ content }}

    请参考上面的内容，重新实现所有文件下方法体标记了如下内容的方法：

    ```python
    raise NotImplementedError("This function should be implemented by the model.")
    ```
    
    {{ instruction }}
        
    '''
    pass

@byzerllm.prompt(render="jinja")
def instruction_template(instruction:str, content:str)->str:
    '''
    下面是一些文件路径以及每个文件对应的源码：

    {{ content }}    
    
    {{ instruction }}
        
    '''
    pass


def main():
    parser = argparse.ArgumentParser(description="Auto-implement missing methods in a Python script.")
    parser.add_argument("--source_dir", required=True, help="Path to the project")
    parser.add_argument("--git_url", help="URL of the git repository")
    parser.add_argument("--target_file", required=False, help="the file to write the source code to")
    parser.add_argument("--query",  help="the instruction to handle the source code")
    parser.add_argument("--template",  default="common",help="the instruction to handle the source code")
    parser.add_argument("--project_type",  default="py",help="the type of the project. py ts,or py-script, default is py")
    parser.add_argument("--execute", action='store_true', help="Execute command line or not")    

    parser.add_argument("--package_name",  default="",help="only works for py-script project type. The package name of the script. default is empty.")
    parser.add_argument("--script_path",  default="",help="only works for py-script project type. The path to the Python script. default is empty.")

    parser.add_argument("--model",  default="",help="the model name to use")

    args = parser.parse_args()

    if args.model:
        byzerllm.connect_cluster()
        llm = byzerllm.ByzerLLM()
        llm.setup_template(model=args.model,template="auto")
        llm.setup_default_model_name(args.model)
    else:
        llm = None

    source_dir = args.source_dir    
    git_url = args.git_url or None
    target_file = args.target_file or None    
    template = args.template 
    project_type = args.project_type
    should_execute = args.execute


    if project_type == "ts":
        pp = TSProject(source_dir=source_dir, git_url=git_url, target_file=target_file)
    elif project_type == "py-script":
        pp = Level1PyProject(script_path=args.script_path, package_name=args.package_name)          
    else:
        pp = PyProject(source_dir=source_dir, git_url=git_url, target_file=target_file)

    pp.run()
    content = pp.output()
    
    if template == "common":
        instruction = args.query or "Please implement the following methods"
        content = instruction_template(instruction=instruction, content=content)
    elif template == "auto_implement":            
        content = auto_implement_function_template(instruction="", content=content)
        
    if should_execute:
        t = llm.chat_oai(conversations=[{
            "role": "user",
            "content": content
        }]) 
        content = t[0].output
    
    with open(target_file, "w") as file:        
        file.write(content)

if __name__ == "__main__":
    main()

##File: /home/winubuntu/projects/ByzerRawCopilot/src/autocoder/version.py
__version__ = "0.1.0"

##File: /home/winubuntu/projects/ByzerRawCopilot/src/autocoder/suffixproject/__init__.py
from autocoder.common import SourceCode
from autocoder import common as FileUtils  
import os
from typing import Optional,Generator,List,Dict,Any
from git import Repo

class SuffixProject():
    
    def __init__(self,source_dir,
                 project_type:str,
                 git_url:Optional[str]=None,
                 target_file:Optional[str]=None):
        self.directory = source_dir
        self.git_url = git_url        
        self.target_file = target_file  
        self.project_type = project_type
        self.suffixs = [f".{suffix}" if not suffix.startswith('.') else suffix for suffix in self.project_type.split(",")]

    def output(self):
        return open(self.target_file, "r").read()                

    def is_suffix_file(self,file_path):
        return any([file_path.endswith(suffix) for suffix in self.suffixs])

    def read_file_content(self,file_path):
        with open(file_path, "r") as file:
            return file.read()

    def convert_to_source_code(self,file_path):        
        if not FileUtils.is_likely_useful_file(file_path):
            return None
               
        module_name = file_path
        source_code = self.read_file_content(file_path)

        if not FileUtils.has_sufficient_content(source_code,min_line_count=1):
            return None
        
        if FileUtils.is_test_file(source_code):
            return None
        return SourceCode(module_name=module_name, source_code=source_code)
    

    def get_source_codes(self)->Generator[SourceCode,None,None]:
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                if self.is_suffix_file(file_path):
                    source_code = self.convert_to_source_code(file_path)
                    if source_code is not None:
                        yield source_code


    def run(self):
        if self.git_url is not None:
            self.clone_repository()

        if self.target_file is None:                
            for code in self.get_source_codes():
                print(f"##File: {code.module_name}")
                print(code.source_code)                
        else:            
            with open(self.target_file, "w") as file:
                for code in self.get_source_codes():
                    file.write(f"##File: {code.module_name}\n")
                    file.write(f"{code.source_code}\n\n")
                    
    
    def clone_repository(self):   
        if self.git_url is None:
            raise ValueError("git_url is required to clone the repository")
             
        if os.path.exists(self.directory):
            print(f"Directory {self.directory} already exists. Skipping cloning.")
        else:
            print(f"Cloning repository {self.git_url} into {self.directory}")
            Repo.clone_from(self.git_url, self.directory)

##File: /home/winubuntu/projects/ByzerRawCopilot/src/autocoder/pyproject/__init__.py
from autocoder.common import SourceCode
from autocoder import common as FileUtils
import os
from typing import Optional,Generator,List,Dict,Any
from git import Repo
import ast
import importlib
import byzerllm

class Level1PyProject():
    
    def __init__(self,script_path,package_name):
        self.script_path = script_path
        self.package_name = package_name

    def get_imports_from_script(self,file_path):
        script = ""
        with open(file_path, "r") as file:
            script = file.read()
            tree = ast.parse(script, filename=file_path)
        
        imports = [node for node in ast.walk(tree) if isinstance(node, (ast.Import, ast.ImportFrom))]
        return imports,script

    def filter_imports(self,imports, package_name):
        filtered_imports = []
        for import_ in imports:
            if isinstance(import_, ast.Import):
                for alias in import_.names:
                    if alias.name.startswith(package_name):
                        filtered_imports.append(alias.name)
            elif isinstance(import_, ast.ImportFrom):
                if import_.module and import_.module.startswith(package_name):
                    filtered_imports.append(import_.module)
        return filtered_imports



    def fetch_source_code(self,import_name):
        spec = importlib.util.find_spec(import_name)
        if spec and spec.origin:
            with open(spec.origin, "r") as file:
                return file.read()
        return None
    
    @byzerllm.prompt(render="jinja")
    def auto_implement(self,instruction:str, sources:List[Dict[str,Any]])->str:
        '''
        下面是一些Python 模块以及对应的源码：

        {% for source in sources %}
        #Module:{{ source.module_name }}
        {{ source.source_code }}
        {% endfor %}

        请参考上面的内容，重新实现 script 模块下所有实现是"pass" 的方法。        
        
        {{ instruction }}
            
        '''
        pass

    def run(self):
        imports,script = self.get_imports_from_script(self.script_path)
        filtered_imports = self.filter_imports(imports, self.package_name)
        sources = [] 


        for import_name in filtered_imports:
            source_code = self.fetch_source_code(import_name)
            if source_code:
                sources.append(SourceCode(module_name=import_name, source_code=source_code))            
            else:
                print(f"Could not fetch source code for {import_name}.")

        sources.append(SourceCode(module_name="script", source_code=script))

        sources = [source.dict() for source in sources]
        return self.auto_implement(instruction="", sources=sources)

class PyProject():
    
    def __init__(self,source_dir,git_url:Optional[str]=None,target_file:Optional[str]=None):
        self.directory = source_dir
        self.git_url = git_url        
        self.target_file = target_file       

    def output(self):
        return open(self.target_file, "r").read()                

    def is_python_file(self,file_path):
        return file_path.endswith(".py")

    def read_file_content(self,file_path):
        with open(file_path, "r") as file:
            return file.read()

    def convert_to_source_code(self,file_path):        
        if not FileUtils.is_likely_useful_file(file_path):
            return None
               
        module_name = file_path
        source_code = self.read_file_content(file_path)

        if not FileUtils.has_sufficient_content(source_code,min_line_count=1):
            return None
        
        if FileUtils.is_test_file(source_code):
            return None
        return SourceCode(module_name=module_name, source_code=source_code)
    

    def get_source_codes(self)->Generator[SourceCode,None,None]:
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                if self.is_python_file(file_path):
                    source_code = self.convert_to_source_code(file_path)
                    if source_code is not None:
                        yield source_code


    def run(self):
        if self.git_url is not None:
            self.clone_repository()

        if self.target_file is None:                
            for code in self.get_source_codes():
                print(f"##File: {code.module_name}")
                print(code.source_code)                
        else:            
            with open(self.target_file, "w") as file:
                for code in self.get_source_codes():
                    file.write(f"##File: {code.module_name}\n")
                    file.write(f"{code.source_code}\n\n")
                    
    
    def clone_repository(self):   
        if self.git_url is None:
            raise ValueError("git_url is required to clone the repository")
             
        if os.path.exists(self.directory):
            print(f"Directory {self.directory} already exists. Skipping cloning.")
        else:
            print(f"Cloning repository {self.git_url} into {self.directory}")
            Repo.clone_from(self.git_url, self.directory)


##File: /home/winubuntu/projects/ByzerRawCopilot/src/autocoder/tsproject/__init__.py
from autocoder.common import SourceCode
from autocoder import common as FileUtils  
import os
from typing import Optional,Generator,List,Dict,Any
from git import Repo

class TSProject():
    
    def __init__(self,source_dir,git_url:Optional[str]=None,target_file:Optional[str]=None):
        self.directory = source_dir
        self.git_url = git_url        
        self.target_file = target_file       

    def output(self):
        return open(self.target_file, "r").read()                    

    def read_file_content(self,file_path):
        with open(file_path, "r") as file:
            return file.read()            

    def is_likely_useful_file(self,file_path):
        # Ignore hidden files and directories
        if any(part.startswith(".") for part in file_path.split(os.path.sep)):
            return False

        # Ignore common build output, dependency and configuration directories
        ignore_dirs = [
            "node_modules",
            "dist",
            "build",
            "coverage",
            "public",
            "config",
            "__tests__",
            "__mocks__",
        ]
        if any(dir in file_path.split(os.path.sep) for dir in ignore_dirs):
            return False

        # Ignore common non-source files in React + TS projects 
        ignore_extensions = [
            ".json",
            ".md",
            ".txt",
            ".png",
            ".jpg",
            ".jpeg",
            ".gif",
            ".svg",
            ".ico",
            ".css",
            ".less",
            ".scss",
            ".sass",
            ".map",
        ]
        if any(file_path.endswith(ext) for ext in ignore_extensions):
            return False
        
        # Include .ts, .tsx, .js and .jsx files
        include_extensions = [".ts", ".tsx", ".js", ".jsx"]
        if any(file_path.endswith(ext) for ext in include_extensions):
            return True

        return False    

    def convert_to_source_code(self,file_path):        
        if not self.is_likely_useful_file(file_path):
            return None
               
        module_name = file_path
        source_code = self.read_file_content(file_path)

        if not FileUtils.has_sufficient_content(source_code,min_line_count=1):
            return None
        
        if FileUtils.is_test_file(source_code):
            return None
        return SourceCode(module_name=module_name, source_code=source_code)
    

    def get_source_codes(self)->Generator[SourceCode,None,None]:
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                source_code = self.convert_to_source_code(file_path)
                if source_code is not None:
                    yield source_code
                    


    def run(self):
        if self.git_url is not None:
            self.clone_repository()

        if self.target_file is None:                
            for code in self.get_source_codes():
                print(f"##File: {code.module_name}")
                print(code.source_code)                
        else:            
            with open(self.target_file, "w") as file:
                for code in self.get_source_codes():
                    file.write(f"##File: {code.module_name}\n")
                    file.write(f"{code.source_code}\n\n")
                    
    
    def clone_repository(self):   
        if self.git_url is None:
            raise ValueError("git_url is required to clone the repository")
             
        if os.path.exists(self.directory):
            print(f"Directory {self.directory} already exists. Skipping cloning.")
        else:
            print(f"Cloning repository {self.git_url} into {self.directory}")
            Repo.clone_from(self.git_url, self.directory)

##File: /home/winubuntu/projects/ByzerRawCopilot/build/lib/autocoder/version.py
__version__ = "0.1.0"

##File: /home/winubuntu/projects/ByzerRawCopilot/build/lib/autocoder/pyproject/__init__.py
from autocoder.common import SourceCode
from autocoder import common as FileUtils
import os
from typing import Optional,Generator,List,Dict,Any
from git import Repo
import ast
import importlib
import byzerllm

class Level1PyProject():
    
    def __init__(self,script_path,package_name):
        self.script_path = script_path
        self.package_name = package_name

    def get_imports_from_script(self,file_path):
        script = ""
        with open(file_path, "r") as file:
            script = file.read()
            tree = ast.parse(script, filename=file_path)
        
        imports = [node for node in ast.walk(tree) if isinstance(node, (ast.Import, ast.ImportFrom))]
        return imports,script

    def filter_imports(self,imports, package_name):
        filtered_imports = []
        for import_ in imports:
            if isinstance(import_, ast.Import):
                for alias in import_.names:
                    if alias.name.startswith(package_name):
                        filtered_imports.append(alias.name)
            elif isinstance(import_, ast.ImportFrom):
                if import_.module and import_.module.startswith(package_name):
                    filtered_imports.append(import_.module)
        return filtered_imports



    def fetch_source_code(self,import_name):
        spec = importlib.util.find_spec(import_name)
        if spec and spec.origin:
            with open(spec.origin, "r") as file:
                return file.read()
        return None
    
    @byzerllm.prompt(render="jinja")
    def auto_implement(self,instruction:str, sources:List[Dict[str,Any]])->str:
        '''
        下面是一些Python 模块以及对应的源码：

        {% for source in sources %}
        #Module:{{ source.module_name }}
        {{ source.source_code }}
        {% endfor %}

        请参考上面的内容，重新实现 script 模块下所有实现是"pass" 的方法。        
        
        {{ instruction }}
            
        '''
        pass

    def run(self):
        imports,script = self.get_imports_from_script(self.script_path)
        filtered_imports = self.filter_imports(imports, self.package_name)
        sources = [] 


        for import_name in filtered_imports:
            source_code = self.fetch_source_code(import_name)
            if source_code:
                sources.append(SourceCode(module_name=import_name, source_code=source_code))            
            else:
                print(f"Could not fetch source code for {import_name}.")

        sources.append(SourceCode(module_name="script", source_code=script))

        sources = [source.dict() for source in sources]
        return self.auto_implement(instruction="", sources=sources)

class PyProject():
    
    def __init__(self,source_dir,git_url:Optional[str]=None,target_file:Optional[str]=None):
        self.directory = source_dir
        self.git_url = git_url        
        self.target_file = target_file       

    def output(self):
        return open(self.target_file, "r").read()                

    def is_python_file(self,file_path):
        return file_path.endswith(".py")

    def read_file_content(self,file_path):
        with open(file_path, "r") as file:
            return file.read()

    def convert_to_source_code(self,file_path):        
        if not FileUtils.is_likely_useful_file(file_path):
            return None
               
        module_name = file_path
        source_code = self.read_file_content(file_path)

        if not FileUtils.has_sufficient_content(source_code,min_line_count=1):
            return None
        
        if FileUtils.is_test_file(source_code):
            return None
        return SourceCode(module_name=module_name, source_code=source_code)
    

    def get_source_codes(self)->Generator[SourceCode,None,None]:
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                if self.is_python_file(file_path):
                    source_code = self.convert_to_source_code(file_path)
                    if source_code is not None:
                        yield source_code


    def run(self):
        if self.git_url is not None:
            self.clone_repository()

        if self.target_file is None:                
            for code in self.get_source_codes():
                print(f"##File: {code.module_name}")
                print(code.source_code)                
        else:            
            with open(self.target_file, "w") as file:
                for code in self.get_source_codes():
                    file.write(f"##File: {code.module_name}\n")
                    file.write(f"{code.source_code}\n\n")
                    
    
    def clone_repository(self):   
        if self.git_url is None:
            raise ValueError("git_url is required to clone the repository")
             
        if os.path.exists(self.directory):
            print(f"Directory {self.directory} already exists. Skipping cloning.")
        else:
            print(f"Cloning repository {self.git_url} into {self.directory}")
            Repo.clone_from(self.git_url, self.directory)


##File: /home/winubuntu/projects/ByzerRawCopilot/build/lib/autocoder/tsproject/__init__.py
from autocoder.common import SourceCode
from autocoder import common as FileUtils  
import os
from typing import Optional,Generator,List,Dict,Any
from git import Repo

class TSProject():
    
    def __init__(self,source_dir,git_url:Optional[str]=None,target_file:Optional[str]=None):
        self.directory = source_dir
        self.git_url = git_url        
        self.target_file = target_file       

    def output(self):
        return open(self.target_file, "r").read()                

    def is_typescript_file(self,file_path):
        return file_path.endswith(".ts") or file_path.endswith(".tsx")

    def read_file_content(self,file_path):
        with open(file_path, "r") as file:
            return file.read()

    def convert_to_source_code(self,file_path):        
        if not FileUtils.is_likely_useful_file(file_path):
            return None
               
        module_name = file_path
        source_code = self.read_file_content(file_path)

        if not FileUtils.has_sufficient_content(source_code,min_line_count=1):
            return None
        
        if FileUtils.is_test_file(source_code):
            return None
        return SourceCode(module_name=module_name, source_code=source_code)
    

    def get_source_codes(self)->Generator[SourceCode,None,None]:
        for root, dirs, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                if self.is_typescript_file(file_path):
                    source_code = self.convert_to_source_code(file_path)
                    if source_code is not None:
                        yield source_code


    def run(self):
        if self.git_url is not None:
            self.clone_repository()

        if self.target_file is None:                
            for code in self.get_source_codes():
                print(f"##File: {code.module_name}")
                print(code.source_code)                
        else:            
            with open(self.target_file, "w") as file:
                for code in self.get_source_codes():
                    file.write(f"##File: {code.module_name}\n")
                    file.write(f"{code.source_code}\n\n")
                    
    
    def clone_repository(self):   
        if self.git_url is None:
            raise ValueError("git_url is required to clone the repository")
             
        if os.path.exists(self.directory):
            print(f"Directory {self.directory} already exists. Skipping cloning.")
        else:
            print(f"Cloning repository {self.git_url} into {self.directory}")
            Repo.clone_from(self.git_url, self.directory)

    

优化 src 目录外的auto_coder.py, 生成一个新的pydantic model, 提供一个方法自动将 argparse 参数转换为 pydantic model。
    